<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GeoGuessr Clone</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
   integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
   crossorigin="anonymous" />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      height: 100vh;
      overflow: hidden;
    }
    .container {
      max-width: 100%;
      margin: 0;
      padding: 0;
      height: 100vh;
      position: relative;
    }
    .game-title {
      position: absolute;
      top: 15px;
      left: 15px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 4px;
      z-index: 1000;
      font-size: 1.2em;
    }
    .street-view {
      width: 100%;
      height: 100vh;
      background-color: #fff;
      position: relative;
    }
    .map-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 300px;
      height: 300px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      transition: all 0.5s ease-in-out, transform 0.3s ease-in-out;
      transform-origin: bottom right;
    }
    .map-container.expanded {
      width: 600px;
      height: 400px;
      bottom: 50%;
      right: 50%;
      transform: translate(50%, 50%);
      transform-origin: center center;
    }
    .map-container:not(.expanded):hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    #map {
      width: 100%;
      height: 100%;
      border-radius: 8px 8px 0 0;
      transition: transform 0.3s ease-in-out;
      transform-origin: bottom right;
    }
    .controls {
      padding: 10px;
      background: white;
      border-radius: 0 0 8px 8px;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .compass {
      position: absolute;
      top: 15px;
      right: 20px;
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    .compass::before {
      content: "N";
      position: absolute;
      top: 5px;
      color: #ff0000;
    }
    .compass::after {
      content: "S";
      position: absolute;
      bottom: 5px;
      color: #000;
    }
    .compass-arrow {
      width: 2px;
      height: 20px;
      background: #000;
      position: absolute;
      top: 50%;
      left: 50%;
      transform-origin: bottom center;
      transform: translate(-50%, -100%);
    }
    .score-display {
      position: absolute;
      top: 70px;
      left: 15px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 1000;
    }
    .round-counter {
      position: absolute;
      top: 125px;
      left: 15px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 1000;
    }
    .distance-display,
    .country-display {
      font-size: 14px;
      color: #333;
      margin-top: 5px;
      display: none; /* Initially hidden */
    }
    button {
      background-color: #4CAF50;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    /* Apply scaling only to the map div on container hover */
    .map-container:not(.expanded):hover #map {
        transform: scale(2);
    }
    #mute-btn {
      position: absolute;
      top: 15px; /* Align with compass top */
      right: 90px; /* Position left of the compass */
      z-index: 1001; /* Slightly above other overlays */
      background: rgba(0, 0, 0, 0.4);
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 16px;
      line-height: 30px; /* Center icon vertically */
      text-align: center;
      cursor: pointer;
      padding: 0;
    }
    #mute-btn:hover {
      background: rgba(0, 0, 0, 0.6);
    }
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      display: flex; /* Use flexbox for centering */
      justify-content: center;
      align-items: center;
      font-size: 2em;
      z-index: 2000; /* Ensure it's on top */
      display: none; /* Hidden by default */
    }
    #loading-overlay button {
      /* Style the button inside the overlay */
      margin-top: 20px;
      padding: 10px 25px;
      font-size: 0.8em; 
      display: none; /* Hidden initially */
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div id="loading-overlay">
    <div>
      <div id="loading-text">Loading Location...</div>
      <button id="start-round-button">Start Round</button>
    </div>
  </div>

  <div class="container">
    <div id="street-view" class="street-view">
      <h1 class="game-title">GeoGuessr Clone</h1>
      <button id="mute-btn" title="Mute/Unmute Music">ðŸ”Š</button>
      <div class="compass">
        <div class="compass-arrow"></div>
      </div>
      <div class="score-display">
        Score: <span id="score">0</span>
      </div>
      <div class="round-counter">
        Round: <span id="round">1</span>/5
      </div>
    </div>
    <div class="map-container">
      <div id="map"></div>
      <div class="controls">
        <div id="distance-display" class="distance-display">Distance: <span>...</span></div>
        <div id="actual-country-display" class="country-display">Actual Country: <span>...</span></div>
        <div id="guessed-country-display" class="country-display">Guessed Country: <span>...</span></div>
        <button id="guess-btn" onclick="makeGuess()">Make Guess</button>
        <button id="next-btn" onclick="nextRound()" style="display: none;">Next Round</button>
      </div>
    </div>
  </div>

  <!-- Background Music -->
  <audio id="background-music" src="music.mp3" loop></audio>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    let map = null;
    let marker = null;
    let panorama = null;
    let currentLocation = null;
    let currentRound = 1;
    const maxRounds = 5;
    let totalScore = 0;
    let usedLocations = [];
    let roundResults = []; // Array to store results for final display

    // Function to generate random coordinates
    function getRandomCoordinates() {
      // Generate random latitude between -55 and 70 (excluding extreme north/south)
      const lat = Math.random() * 125 - 55;
      // Generate random longitude between -180 and 180
      const lng = Math.random() * 360 - 180;
      return { lat, lng };
    }

    // Function to check if a location has Street View coverage
    function checkStreetViewCoverage(lat, lng) {
      return new Promise((resolve) => {
        const sv = new google.maps.StreetViewService();
        sv.getPanorama({ location: { lat, lng }, radius: 50000 }, (data, status) => {
          if (status === 'OK') {
            resolve({
              hasCoverage: true,
              location: {
                lat: data.location.latLng.lat(),
                lng: data.location.latLng.lng()
              }
            });
          } else {
            resolve({ hasCoverage: false });
          }
        });
      });
    }

    // Function to find a random location with Street View coverage AND known country
    async function findRandomLocation() {
      let attempts = 0;
      const maxAttempts = 50; 

      while (attempts < maxAttempts) {
        const coords = getRandomCoordinates();
        
        const isUsed = usedLocations.some(loc => 
          Math.abs(loc.lat - coords.lat) < 0.1 && 
          Math.abs(loc.lng - coords.lng) < 0.1
        );

        if (!isUsed) {
          console.log(`Attempt ${attempts + 1}: Checking ${coords.lat}, ${coords.lng}`);
          // --- Check Coverage --- 
          let coverageStatus = 'UNKNOWN'; // Variable to store status
          const coverageResult = await checkStreetViewCoverage(coords.lat, coords.lng)
             .then(result => { 
                 coverageStatus = result.status || 'OK'; // Store status ('OK' if status field missing but data present)
                 return result; 
             })
             .catch(err => { 
                 console.error("Error during coverage check:", err);
                 coverageStatus = 'ERROR_CHECKING';
                 return { hasCoverage: false }; // Treat error as no coverage
             });
          // -------------------

          if (coverageResult.hasCoverage) {
            console.log(`Coverage found at ${coverageResult.location.lat}, ${coverageResult.location.lng}. Checking country...`);
            // --- Check Country --- 
            let geocodeStatus = 'UNKNOWN';
            const country = await getCountryFromLatLng(coverageResult.location.lat, coverageResult.location.lng)
              .then(result => { 
                  geocodeStatus = result.status; // Store status
                  return result.country;
              })
              .catch(err => { 
                  console.error("Error during geocoding:", err);
                  geocodeStatus = 'ERROR_CHECKING';
                  return "Unknown"; // Treat error as Unknown country
              });
            // -------------------
            
            if (country !== "Unknown") {
              console.log(`Found valid location in ${country}.`);
              usedLocations.push(coverageResult.location);
              await new Promise(resolve => setTimeout(resolve, 500)); 
              return coverageResult.location;
            } else {
              console.log(`Skipping location due to unknown country. Geocode Status: ${geocodeStatus}`);
            }
          } else {
             console.log(`No coverage found. Coverage Status: ${coverageStatus}`);
          }
        }
        
        attempts++;
        
        // Delay before next attempt
        if (attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 500)); 
        }
      }

      console.error('Could not find a suitable Street View location after', maxAttempts, 'attempts.');
      // Throw an error instead of retrying recursively
      throw new Error(`Failed to find a valid location after ${maxAttempts} attempts.`); 
    }

    // Initialize the game
    function initGame() {
      // Initialize map
      map = L.map('map').setView([0, 0], 2);
      L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19,
        minZoom: 0
      }).addTo(map);

      // Load Google Maps API with key directly in URL
      const script = document.createElement('script');
      // Use the key directly here
      script.src = `https://maps.googleapis.com/maps/api/js?key=AIzaSyBJQmU6Bt9rHC2G5oHQFVjPbZcXomI9duU&libraries=places`; 
      script.async = true;
      script.defer = true;
      script.onload = startNewRound;
      document.head.appendChild(script);
    }

    // Helper function to get country from coordinates
    function getCountryFromLatLng(lat, lng) {
      return new Promise((resolve, reject) => {
        const geocoder = new google.maps.Geocoder();
        const latlng = { lat: lat, lng: lng };
        geocoder.geocode({ location: latlng }, (results, status) => {
          let country = "Unknown";
          if (status === "OK") {
            if (results[0]) {
              for (const component of results[0].address_components) {
                if (component.types.includes("country")) {
                  country = component.long_name;
                  break; // Found country, exit loop
                }
              }
              // If loop finishes without finding country, it remains "Unknown"
            } // else: No results, country remains "Unknown"
          } else {
            console.error("Geocoder failed due to: " + status);
            // Geocoding failed, country remains "Unknown"
          }
          resolve({ country: country, status: status }); // Resolve with both country and status
        });
      });
    }

    // Start a new round
    async function startNewRound() {
      const loadingOverlay = document.getElementById('loading-overlay');
      const loadingText = document.getElementById('loading-text');
      const startRoundBtn = document.getElementById('start-round-button');
      
      // Reset overlay state
      loadingText.textContent = 'Loading Location...';
      startRoundBtn.style.display = 'none';
      startRoundBtn.onclick = null; // Remove previous listener if any
      loadingOverlay.style.display = 'flex'; // Show loading overlay
      
      let locationFound = false;

      try {
        console.log("Starting location search...");
        try {
          currentLocation = await findRandomLocation();
          locationFound = true; 
        } catch (findError) {
          console.error("findRandomLocation failed:", findError);
          alert("Having trouble finding a suitable location. Please try refreshing the page.");
          loadingOverlay.style.display = 'none';
          return; // Stop if location finding failed
        }
        
        // Location found - update overlay and wait for user click
        console.log("Location found, waiting for user to start round...");
        loadingText.textContent = 'Location Ready!';
        startRoundBtn.style.display = 'block';

        // Add a one-time listener to the button
        startRoundBtn.onclick = () => {
          console.log("Start Round button clicked, initializing panorama...");
          loadingOverlay.style.display = 'none'; // Hide overlay first

          try { // Wrap the rest in a try block
            // Initialize Street View 
            panorama = new google.maps.StreetViewPanorama(
              document.getElementById('street-view'),
              {
                position: { lat: currentLocation.lat, lng: currentLocation.lng },
                pov: { heading: 165, pitch: 0 },
                zoom: 1,
                addressControl: false,
                showRoadLabels: false,
                zoomControl: false,
                panControl: false,
                fullscreenControl: false,
                motionTracking: false,
                motionTrackingControl: false
              }
            );
            
            console.log("Panorama initialized.");

            // Add compass rotation handler
            panorama.addListener('pov_changed', function() {
              const compass = document.querySelector('.compass');
              const heading = panorama.getPov().heading;
              compass.style.transform = `rotate(${heading}deg)`;
            });

            // Reset map and marker
            map.setView([0, 0], 2);
            map.eachLayer(function (layer) {
                if (layer instanceof L.Marker || layer instanceof L.Polyline) {
                    map.removeLayer(layer);
                }
            });
            marker = null;

            // Reset UI
            console.log('Resetting UI for new round');
            document.getElementById('guess-btn').style.display = 'block';
            document.getElementById('next-btn').style.display = 'none';
            document.getElementById('round').textContent = currentRound;
            document.getElementById('distance-display').style.display = 'none';
            document.getElementById('actual-country-display').style.display = 'none'; 
            document.getElementById('guessed-country-display').style.display = 'none';

            // Add click handler to map
            map.on('click', function(e) {
              if (marker) {
                map.removeLayer(marker);
              }
              marker = L.marker(e.latlng).addTo(map);
            });
          } catch(initError) {
             console.error("Error during round initialization after button click:", initError);
             alert("An error occurred starting the round. Please refresh.");
             // Ensure overlay is hidden even if error occurs here
             loadingOverlay.style.display = 'none';
          }
        }; // End of button onclick listener

      } catch (error) {
        // This outer catch mainly handles unexpected errors before findRandomLocation finishes
        console.error('Error starting new round (outer try):', error);
        if (!locationFound) { 
            alert('An error occurred while searching for a location. Please try refreshing.');
        }
        loadingOverlay.style.display = 'none';
      }
    }

    // Make a guess
    async function makeGuess() {
      console.log('Make guess called');
      if (!marker) {
        alert('Please click on the map to place your guess!');
        return;
      }

      const guessLat = marker.getLatLng().lat;
      const guessLng = marker.getLatLng().lng;
      const distance = calculateDistance(
        guessLat, guessLng,
        currentLocation.lat, currentLocation.lng
      );

      const score = Math.max(0, Math.round(5000 * Math.exp(-distance / 2000)));
      totalScore += score;

      // -- Store results for final display --
      roundResults.push({
        guessLatLng: { lat: guessLat, lng: guessLng },
        actualLatLng: { lat: currentLocation.lat, lng: currentLocation.lng }
      });
      // -------------------------------------

      // --- Draw current round guess/actual/line --- 
      const actualMarker = L.marker([currentLocation.lat, currentLocation.lng], {
        icon: L.divIcon({
          className: 'actual-location-marker',
          html: '<div style="background-color: red; width: 12px; height: 12px; border-radius: 50%; border: 1px solid white;"></div>',
          iconSize: [12, 12],
          iconAnchor: [6, 6]
        })
      }).addTo(map);

      const line = L.polyline([
        [guessLat, guessLng],
        [currentLocation.lat, currentLocation.lng]
      ], {
        color: 'red',
        weight: 2,
        opacity: 0.7
      }).addTo(map);

      // Fit map to show current guess and actual location
      const bounds = L.latLngBounds([
        [guessLat, guessLng],
        [currentLocation.lat, currentLocation.lng]
      ]);
      map.fitBounds(bounds, { padding: [50, 50] });
      // ---------------------------------------------

      // --- Get Country Information --- 
      console.log('Getting country information...');
      let actualCountry = "Unknown";
      let guessedCountry = "Unknown";
      try {
        console.log('Calling Promise.all for getCountryFromLatLng...');
        // Use Promise.all to run geocoding requests in parallel
        [actualCountry, guessedCountry] = await Promise.all([
          getCountryFromLatLng(currentLocation.lat, currentLocation.lng).then(res => res.country), // Extract country
          getCountryFromLatLng(guessLat, guessLng).then(res => res.country)          // Extract country
        ]);
        console.log(`Countries fetched - Actual: ${actualCountry}, Guessed: ${guessedCountry}`);
      } catch (error) {
        console.error("Error during reverse geocoding:", error);
        // Keep default "Unknown" values
      }
      // --- End Get Country Information ---

      // Show results (score, distance, countries) for the current round
      console.log('Updating score display...');
      document.getElementById('score').textContent = totalScore;

      console.log('Updating distance display...');
      const distanceDisplay = document.getElementById('distance-display');
      const distanceSpan = distanceDisplay.querySelector('span');
      if (distance < 1) {
        distanceSpan.textContent = Math.round(distance * 1000) + ' m';
      } else {
        distanceSpan.textContent = Math.round(distance) + ' km';
      }
      distanceDisplay.style.display = 'block';

      console.log(`Updating country displays - Actual: ${actualCountry}, Guessed: ${guessedCountry}`);
      const actualCountryDisplay = document.getElementById('actual-country-display');
      if (actualCountryDisplay) {
        actualCountryDisplay.querySelector('span').textContent = actualCountry;
        actualCountryDisplay.style.display = 'block';
      } else {
        console.error('Actual country display element not found!');
      }

      const guessedCountryDisplay = document.getElementById('guessed-country-display');
      if (guessedCountryDisplay) {
        guessedCountryDisplay.querySelector('span').textContent = guessedCountry;
        guessedCountryDisplay.style.display = 'block';
      } else {
        console.error('Guessed country display element not found!');
      }

      console.log('Updating UI after guess (buttons, map expansion)...');
      // Update UI - Hide guess, show next
      document.getElementById('guess-btn').style.display = 'none';
      document.getElementById('next-btn').style.display = 'block';
      console.log('Next button display set to:', document.getElementById('next-btn').style.display);
      
      console.log('Expanding map container...');
      // Expand the map container
      const mapContainer = document.querySelector('.map-container');
      mapContainer.classList.add('expanded');
      console.log('Map container classes:', mapContainer.className);

      // Remove map click handler
      map.off('click');
    }

    // Move to next round
    function nextRound() {
      console.log('Next round called');
      currentRound++;
      if (currentRound <= maxRounds) {
        console.log('Starting next round setup...');
        // Reset map container size
        const mapContainer = document.querySelector('.map-container');
        mapContainer.classList.remove('expanded');
        console.log('Map container classes:', mapContainer.className);

        // Remove the marker from the last guess
        if (marker) {
          map.removeLayer(marker);
          marker = null;
        }
        
        // Reset buttons and displays for the new round
        document.getElementById('guess-btn').style.display = 'block';
        document.getElementById('next-btn').style.display = 'none';
        document.getElementById('distance-display').style.display = 'none';
        document.getElementById('actual-country-display').style.display = 'none'; 
        document.getElementById('guessed-country-display').style.display = 'none';
        console.log('Reset button and distance/country displays');
        
        startNewRound();
      } else {
        // --- Game Over - Final Results Display ---
        console.log('Game Over - Displaying results');
        const mapContainer = document.querySelector('.map-container');
        mapContainer.classList.add('expanded'); // Ensure map is expanded

        // Clear the last guess marker if it exists
        if (marker) {
          map.removeLayer(marker);
          marker = null;
        }

        // Hide individual round result displays
        document.getElementById('distance-display').style.display = 'none';
        document.getElementById('actual-country-display').style.display = 'none'; 
        document.getElementById('guessed-country-display').style.display = 'none';

        // Array to hold all points for bounds calculation
        const allPoints = [];
        
        // Iterate and display all results
        roundResults.forEach((result, index) => {
          const guessLatLng = [result.guessLatLng.lat, result.guessLatLng.lng];
          const actualLatLng = [result.actualLatLng.lat, result.actualLatLng.lng];

          allPoints.push(guessLatLng);
          allPoints.push(actualLatLng);

          // Add Guess Marker (Blue with round number)
          L.marker(guessLatLng, {
              icon: L.divIcon({
                className: 'guess-marker-final',
                html: `<div style="background-color: blue; width: 18px; height: 18px; border-radius: 50%; font-size: 10px; color: white; text-align: center; line-height: 18px; border: 1px solid white;">${index + 1}</div>`,
                iconSize: [18, 18],
                iconAnchor: [9, 9]
              })
            }).addTo(map);

          // Add Actual Marker (Red with round number)
          L.marker(actualLatLng, {
            icon: L.divIcon({
              className: 'actual-marker-final',
              html: `<div style="background-color: red; width: 18px; height: 18px; border-radius: 50%; font-size: 10px; color: white; text-align: center; line-height: 18px; border: 1px solid white;">${index + 1}</div>`,
              iconSize: [18, 18],
              iconAnchor: [9, 9]
            })
          }).addTo(map);

          // Add Line (Grey, dashed)
          L.polyline([guessLatLng, actualLatLng], {
            color: 'grey',
            weight: 2,
            opacity: 0.7,
            dashArray: '5, 5'
          }).addTo(map);
        });

        // Fit map to show all points
        if (allPoints.length > 0) {
          const bounds = L.latLngBounds(allPoints);
          map.fitBounds(bounds, { padding: [50, 50] });
        }

        // Update button text and behavior for "Play Again"
        const nextBtn = document.getElementById('next-btn');
        nextBtn.textContent = 'Play Again?';
        nextBtn.style.display = 'block'; // Ensure it's visible
        nextBtn.onclick = function() { // Change the onclick handler
          console.log('Play Again clicked');
          // Reset game state fully
          currentRound = 1;
          totalScore = 0;
          roundResults = []; // Clear the results array
          
          // Reset UI (button text/visibility handled by startNewRound)
          mapContainer.classList.remove('expanded'); 
          nextBtn.onclick = nextRound; // Restore original handler
                    
          // Start a fresh game (clears map layers too)
          startNewRound(); 
        };

        // Optionally display final score message
        alert(`Game Over! Your final score: ${totalScore}`); 
        // --- End Game Over Logic ---
      }
    }

    // Calculate distance between two points
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Earth's radius in km
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function toRad(degrees) {
      return degrees * (Math.PI/180);
    }

    // --- Music Control ---
    function setupMusicControl() {
      const audio = document.getElementById('background-music');
      const muteBtn = document.getElementById('mute-btn');
      
      // Set initial soft volume
      audio.volume = 0.2;

      // Attempt to play on load (might be blocked by browser until interaction)
      audio.play().catch(error => {
        console.log("Audio autoplay blocked by browser. Waiting for user interaction.");
        // Optional: Try playing again after first interaction, e.g., map click
      });

      muteBtn.addEventListener('click', () => {
        audio.muted = !audio.muted;
        muteBtn.textContent = audio.muted ? 'ðŸ”‡' : 'ðŸ”Š';
        muteBtn.title = audio.muted ? 'Unmute Music' : 'Mute Music';
      });
    }
    // --- End Music Control ---

    // Start the game when the page loads
    window.onload = () => {
      initGame();
      setupMusicControl(); // Call music setup after game init
    };
  </script>
</body>
</html> 